% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BM_StandardErrors.R
\name{dfadjustSE}
\alias{dfadjustSE}
\title{Standard Errors with adjusted degrees of freedom}
\usage{
dfadjustSE(model, clustervar = NULL, ell = NULL, IK = TRUE,
  tol = 1e-09)
}
\arguments{
\item{model}{Fitted model returned by the \code{\link{lm}} function}

\item{clustervar}{Factor variable that defines clusters. If \code{NULL} (or
not supplied), the command computes heteroscedasticity-robust standard
errors, rather than cluster-robust standard errors.}

\item{ell}{A vector of the same length as the dimension of covariates,
specifying which linear combination \eqn{\ell'\beta} of coefficients
\eqn{\beta} to compute. If \code{NULL}, compute standard errors for each
regressor coefficient}

\item{IK}{Logical flag only relevant if cluster-robust standard errors are
being computed. Specifies whether to compute the degrees-of-freedom
adjustment using the Imbens-Kolesár method (if \code{TRUE}), or the
Bell-McCaffrey method (if \code{FALSE})}

\item{tol}{Numerical tolerance for determining whether an eigenvalue equals zero.}
}
\value{
Returns a list with the following components \describe{

\item{vcov}{Variance-covariance matrix estimator. For the case without
clustering, it corresponds to the HC2 estimator (see MacKinnon and White,
1985 and the reference manual for the \code{sandwich} package). For the case
with clustering, it corresponds to a generalization of the HC2 estimator,
called LZ2 in Imbens and Kolesár.}

\item{dof}{Degrees-of-freedom adjustment}

\item{se}{Standard error}

\item{adj.se}{Adjusted standard errors. For \eqn{\beta_j}, they are defined as
\code{adj.se[j]=sqrt(vcov[j,j]se*qt(0.975,df=dof)} so that the Bell-McCaffrey
confidence intervals are given as \code{coefficients(fm)[j] +- 1.96* adj.se=}}

\item{se.Stata}{Square root of the cluster-robust variance estimator used in
STATA}

}
}
\description{
Standard Errors with adjusted degrees of freedom
}
\examples{
## No clustering:
set.seed(42)
x <- sin(1:10)
y <- rnorm(10)
fm <- lm(y~x)
dfadjustSE(fm)
## Clustering, defining the first six observations to be in cluster 1, the
#next two in cluster 2, and the last three in cluster three.
clustervar <- as.factor(c(rep(1, 6), rep(2, 2), rep(3, 2)))
dfadjustSE(fm, clustervar)
}
